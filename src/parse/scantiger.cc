// src/parse/scantiger.cc generated by reflex 6.0.0 from src/parse/scantiger.ll

#define REFLEX_VERSION "6.0.0"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_YYLTYPE
#undef REFLEX_OPTION_YYSTYPE
#undef REFLEX_OPTION_bison_cc
#undef REFLEX_OPTION_bison_cc_namespace
#undef REFLEX_OPTION_bison_cc_parser
#undef REFLEX_OPTION_bison_complete
#undef REFLEX_OPTION_bison_locations
#undef REFLEX_OPTION_debug
#undef REFLEX_OPTION_flex
#undef REFLEX_OPTION_header_file
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_noyywrap
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_params
#undef REFLEX_OPTION_prefix
#undef REFLEX_OPTION_token_eof
#undef REFLEX_OPTION_token_type

#define REFLEX_OPTION_YYLTYPE             parse::location
#define REFLEX_OPTION_YYSTYPE             parse::parser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  parse
#define REFLEX_OPTION_bison_cc_parser     parser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_debug               true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_header_file         "src/parse/scantiger.hh"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           parse
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "src/parse/scantiger.cc"
#define REFLEX_OPTION_params              ::parse::TigerDriver& td
#define REFLEX_OPTION_prefix              yy
#define REFLEX_OPTION_token_eof           parse::parser::symbol_type(0, location())
#define REFLEX_OPTION_token_type          parse::parser::symbol_type

// --debug option enables ASSERT:
#define ASSERT(c) assert(c)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 17 "src/parse/scantiger.ll"


#define YY_EXTERN_C extern "C" // For linkage rule

#include <cerrno>
#include <climits>
#include <regex>
#include <string>

#include <boost/lexical_cast.hpp>

#include <misc/contract.hh>
  // Using misc::escape is very useful to quote non printable characters.
  // For instance
  //
  //    std::cerr << misc::escape('\n') << '\n';
  //
  // reports about `\n' instead of an actual new-line character.
#include <misc/escape.hh>
#include <misc/symbol.hh>
#include <parse/parsetiger.hh>
#include <parse/tiger-driver.hh>

  // FIXED: Some code was deleted here (Define YY_USER_ACTION to update locations)
#define YY_USER_ACTION td.location_.columns(yyleng);


#define TOKEN(Type)                             \
  parser::make_ ## Type(td.location_)

#define TOKEN_VAL(Type, Value)                  \
  parser::make_ ## Type(Value, td.location_)

# define CHECK_EXTENSION()                              \
  do {                                                  \
    if (!td.enable_extensions_p_)                       \
      td.error_ << misc::error::error_type::scan        \
                << td.location_                         \
                << ": invalid identifier: `"            \
                << misc::escape(text()) << "'\n";       \
  } while (false)




////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE DEFINITIONS                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define INITIAL (0)
#define SC_COMMENT (1)
#define SC_STRING (2)
#define SC_SINGLE_COMMENT (3)
#define YY_NUM_RULES (86)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS INCLUDE                                                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include "src/parse/scantiger.hh"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "src/parse/scantiger.ll"
/* -*- C++ -*- */
// %option defines the parameters with which the reflex will be launched
#line 4 "src/parse/scantiger.ll"
// To enable compatibility with bison
#line 11 "src/parse/scantiger.ll"
// Add a param of function lex() generate in Lexer class
#line 14 "src/parse/scantiger.ll"
// Name of the class generate by reflex
#line 64 "src/parse/scantiger.ll"
/* Abbreviations.  */
#line 69 "src/parse/scantiger.ll"
/* FIXED: Some code was deleted here. */

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

parse::parser::symbol_type parse::Lexer::lex(::parse::TigerDriver& td)
{
  static const char *REGEX_INITIAL = "(?m)((?:[0-9]+))|((?:\\Q&\\E))|((?:\\Qarray\\E))|((?:\\Q:=\\E))|((?:\\Qbreak\\E))|((?:\\Qcast\\E))|((?:\\Q:\\E))|((?:\\Q,\\E))|((?:\\Q/\\E))|((?:\\Qdo\\E))|((?:\\Q.\\E))|((?:\\Qelse\\E))|((?:\\Qend\\E))|((?:\\Q=\\E))|((?:\\Qfor\\E))|((?:\\Qfunction\\E))|((?:\\Q>=\\E))|((?:\\Q>\\E))|((?:\\Qif\\E))|((?:\\Qimport\\E))|((?:\\Qin\\E))|((?:\\Q{\\E))|((?:\\Q[\\E))|((?:\\Q<=\\E))|((?:\\Qlet\\E))|((?:\\Q(\\E))|((?:\\Q<\\E))|((?:\\Q-\\E))|((?:\\Q<>\\E))|((?:\\Qnil\\E))|((?:\\Qof\\E))|((?:\\Q|\\E))|((?:\\Q+\\E))|((?:\\Qprimitive\\E))|((?:\\Q}\\E))|((?:\\Q]\\E))|((?:\\Q)\\E))|((?:\\Q;\\E))|((?:\\Qthen\\E))|((?:\\Q*\\E))|((?:\\Qto\\E))|((?:\\Qtype\\E))|((?:\\Qvar\\E))|((?:\\Qwhile\\E))|((?:\\Qclass\\E))|((?:\\Qextends\\E))|((?:\\Qmethod\\E))|((?:\\Qnew\\E))|((?:[A-Za-z][0-9A-Z_a-z]*)|(?:(?:\\Q_main\\E)))|((?:\\Q\"\\E))|((?:\\Q//\\E))|((?:\\Q/*\\E))|([\\x09\\x20])|(\\n|\\r|\\n\\r|\\r\\n)|((?:\\Q_exp\\E))|((?:\\Q_lvalue\\E))|((?:\\Q_chunks\\E))|(.)";
  static const reflex::Pattern PATTERN_INITIAL(REGEX_INITIAL);
  static const char *REGEX_SC_COMMENT = "(?m)((?:\\Q/*\\E))|((?:\\Q*/\\E))|(.)";
  static const reflex::Pattern PATTERN_SC_COMMENT(REGEX_SC_COMMENT);
  static const char *REGEX_SC_STRING = "(?m)(\\\\a)|(\\\\b)|(\\\\f)|(\\\\n)|(\\\\r)|(\\\\t)|(\\\\v)|([\\x07-\\x0d])|(\\\\[0-7]{3})|(\\\\x[0-9A-Fa-f]{2})|([\"'])|(\\\\\")|(\\\\\\\\)|(.)|(\\\\.)";
  static const reflex::Pattern PATTERN_SC_STRING(REGEX_SC_STRING);
  static const char *REGEX_SC_SINGLE_COMMENT = "(?m)((?:\\Q//\\E))|(.)|(\\n|\\r|\\n\\r|\\r\\n)";
  static const reflex::Pattern PATTERN_SC_SINGLE_COMMENT(REGEX_SC_SINGLE_COMMENT);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
    YY_USER_INIT
  }
  switch (start())
  {
    case INITIAL:
#line 83 "src/parse/scantiger.ll"
/* The rules.  */
    break;
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule src/parse/scantiger.ll:245\033[0m start(" << start() << ")\n";
#line 245 "src/parse/scantiger.ll"
{ return TOKEN(EOF);}
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:83: {int} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:83\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 83 "src/parse/scantiger.ll"
{
                int val = 0;
                val = std::stoi(text());
  // FIXED: Some code was deleted here (Decode, and check the value).
                return TOKEN_VAL(INT, val);
              }
  /* FIXED: Some code was deleted here. */

            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:91: "&" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:91\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 91 "src/parse/scantiger.ll"
{return TOKEN(AND);}
            YY_BREAK
          case 3: // rule src/parse/scantiger.ll:92: "array" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:92\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 92 "src/parse/scantiger.ll"
{return TOKEN(ARRAY);}
            YY_BREAK
          case 4: // rule src/parse/scantiger.ll:93: ":=" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:93\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 93 "src/parse/scantiger.ll"
{return TOKEN(ASSIGN);}
            YY_BREAK
          case 5: // rule src/parse/scantiger.ll:94: "break" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:94\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 94 "src/parse/scantiger.ll"
{return TOKEN(BREAK);}
            YY_BREAK
          case 6: // rule src/parse/scantiger.ll:95: "cast" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:95\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 95 "src/parse/scantiger.ll"
{return TOKEN(CAST);}

            YY_BREAK
          case 7: // rule src/parse/scantiger.ll:97: ":" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:97\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 97 "src/parse/scantiger.ll"
{return TOKEN(COLON);}
            YY_BREAK
          case 8: // rule src/parse/scantiger.ll:98: "," :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:98\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 98 "src/parse/scantiger.ll"
{return TOKEN(COMMA);}
            YY_BREAK
          case 9: // rule src/parse/scantiger.ll:99: "/" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:99\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 99 "src/parse/scantiger.ll"
{return TOKEN(DIVIDE);}
            YY_BREAK
          case 10: // rule src/parse/scantiger.ll:100: "do" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:100\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 100 "src/parse/scantiger.ll"
{return TOKEN(DO);}
            YY_BREAK
          case 11: // rule src/parse/scantiger.ll:101: "." :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:101\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 101 "src/parse/scantiger.ll"
{return TOKEN(DOT);}
            YY_BREAK
          case 12: // rule src/parse/scantiger.ll:102: "else" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:102\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 102 "src/parse/scantiger.ll"
{return TOKEN(ELSE);}
            YY_BREAK
          case 13: // rule src/parse/scantiger.ll:103: "end" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:103\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 103 "src/parse/scantiger.ll"
{return TOKEN(END);}
            YY_BREAK
          case 14: // rule src/parse/scantiger.ll:104: "=" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:104\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 104 "src/parse/scantiger.ll"
{return TOKEN(EQ);}

            YY_BREAK
          case 15: // rule src/parse/scantiger.ll:106: "for" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:106\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 106 "src/parse/scantiger.ll"
{return TOKEN(FOR);}
            YY_BREAK
          case 16: // rule src/parse/scantiger.ll:107: "function" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:107\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 107 "src/parse/scantiger.ll"
{return TOKEN(FUNCTION);}
            YY_BREAK
          case 17: // rule src/parse/scantiger.ll:108: ">=" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:108\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 108 "src/parse/scantiger.ll"
{return TOKEN(GE);}
            YY_BREAK
          case 18: // rule src/parse/scantiger.ll:109: ">" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:109\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 109 "src/parse/scantiger.ll"
{return TOKEN(GT);}
            YY_BREAK
          case 19: // rule src/parse/scantiger.ll:110: "if" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:110\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 110 "src/parse/scantiger.ll"
{return TOKEN(IF);}
            YY_BREAK
          case 20: // rule src/parse/scantiger.ll:111: "import" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:111\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 111 "src/parse/scantiger.ll"
{return TOKEN(IMPORT);}
            YY_BREAK
          case 21: // rule src/parse/scantiger.ll:112: "in" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:112\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 112 "src/parse/scantiger.ll"
{return TOKEN(IN);}
            YY_BREAK
          case 22: // rule src/parse/scantiger.ll:113: "{" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:113\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 113 "src/parse/scantiger.ll"
{return TOKEN(LBRACE);}
            YY_BREAK
          case 23: // rule src/parse/scantiger.ll:114: "[" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:114\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 114 "src/parse/scantiger.ll"
{return TOKEN(LBRACK);}
            YY_BREAK
          case 24: // rule src/parse/scantiger.ll:115: "<=" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:115\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 115 "src/parse/scantiger.ll"
{return TOKEN(LE);}
            YY_BREAK
          case 25: // rule src/parse/scantiger.ll:116: "let" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:116\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 116 "src/parse/scantiger.ll"
{return TOKEN(LET);}
            YY_BREAK
          case 26: // rule src/parse/scantiger.ll:117: "(" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:117\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 117 "src/parse/scantiger.ll"
{return TOKEN(LPAREN);}
            YY_BREAK
          case 27: // rule src/parse/scantiger.ll:118: "<" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:118\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 118 "src/parse/scantiger.ll"
{return TOKEN(LT);}
            YY_BREAK
          case 28: // rule src/parse/scantiger.ll:119: "-" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:119\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 119 "src/parse/scantiger.ll"
{return TOKEN(MINUS);}

            YY_BREAK
          case 29: // rule src/parse/scantiger.ll:121: "<>" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:121\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 121 "src/parse/scantiger.ll"
{return TOKEN(NE);}

            YY_BREAK
          case 30: // rule src/parse/scantiger.ll:123: "nil" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:123\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 123 "src/parse/scantiger.ll"
{return TOKEN(NIL);}
            YY_BREAK
          case 31: // rule src/parse/scantiger.ll:124: "of" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:124\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 124 "src/parse/scantiger.ll"
{return TOKEN(OF);}
            YY_BREAK
          case 32: // rule src/parse/scantiger.ll:125: "|" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:125\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 125 "src/parse/scantiger.ll"
{return TOKEN(OR);}
            YY_BREAK
          case 33: // rule src/parse/scantiger.ll:126: "+" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:126\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 126 "src/parse/scantiger.ll"
{return TOKEN(PLUS);}
            YY_BREAK
          case 34: // rule src/parse/scantiger.ll:127: "primitive" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:127\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 127 "src/parse/scantiger.ll"
{return TOKEN(PRIMITIVE);}
            YY_BREAK
          case 35: // rule src/parse/scantiger.ll:128: "}" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:128\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 128 "src/parse/scantiger.ll"
{return TOKEN(RBRACE);}
            YY_BREAK
          case 36: // rule src/parse/scantiger.ll:129: "]" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:129\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 129 "src/parse/scantiger.ll"
{return TOKEN(RBRACK);}
            YY_BREAK
          case 37: // rule src/parse/scantiger.ll:130: ")" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:130\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 130 "src/parse/scantiger.ll"
{return TOKEN(RPAREN);}
            YY_BREAK
          case 38: // rule src/parse/scantiger.ll:131: ";" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:131\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 131 "src/parse/scantiger.ll"
{return TOKEN(SEMI);}
            YY_BREAK
          case 39: // rule src/parse/scantiger.ll:132: "then" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:132\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 132 "src/parse/scantiger.ll"
{return TOKEN(THEN);}
            YY_BREAK
          case 40: // rule src/parse/scantiger.ll:133: "*" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:133\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 133 "src/parse/scantiger.ll"
{return TOKEN(TIMES);}
            YY_BREAK
          case 41: // rule src/parse/scantiger.ll:134: "to" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:134\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 134 "src/parse/scantiger.ll"
{return TOKEN(TO);}
            YY_BREAK
          case 42: // rule src/parse/scantiger.ll:135: "type" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:135\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 135 "src/parse/scantiger.ll"
{return TOKEN(TYPE);}
            YY_BREAK
          case 43: // rule src/parse/scantiger.ll:136: "var" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:136\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 136 "src/parse/scantiger.ll"
{return TOKEN(VAR);}
            YY_BREAK
          case 44: // rule src/parse/scantiger.ll:137: "while" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:137\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 137 "src/parse/scantiger.ll"
{return TOKEN(WHILE);}

            YY_BREAK
          case 45: // rule src/parse/scantiger.ll:140: "class" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:140\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 140 "src/parse/scantiger.ll"
{ if (!td.enable_object_extensions_p_)
                  td.error_ << misc::error::error_type::scan << td.location_ << ": invalid identifier: `" << misc::escape(text()) << "'\n";
                else
                  return TOKEN(CLASS);}
            YY_BREAK
          case 46: // rule src/parse/scantiger.ll:144: "extends" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:144\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 144 "src/parse/scantiger.ll"
{if (!td.enable_object_extensions_p_)
                  td.error_ << misc::error::error_type::scan << td.location_ << ": invalid identifier: `" << misc::escape(text()) << "'\n";
               else
                  return TOKEN(EXTENDS);}
            YY_BREAK
          case 47: // rule src/parse/scantiger.ll:148: "method" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:148\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 148 "src/parse/scantiger.ll"
{ if (!td.enable_object_extensions_p_)
                  td.error_ << misc::error::error_type::scan << td.location_ << ": invalid identifier: `" << misc::escape(text()) << "'\n";
               else
                  return TOKEN(METHOD);}
            YY_BREAK
          case 48: // rule src/parse/scantiger.ll:152: "new" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:152\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 152 "src/parse/scantiger.ll"
{ if (!td.enable_object_extensions_p_)
                  td.error_ << misc::error::error_type::scan << td.location_ << ": invalid identifier: `" << misc::escape(text()) << "'\n";
               else
                  return TOKEN(NEW);}

            YY_BREAK
          case 49: // rule src/parse/scantiger.ll:157: {id}|{id_main} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:157\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 157 "src/parse/scantiger.ll"
{return TOKEN_VAL(ID, text());}
            YY_BREAK
          case 50: // rule src/parse/scantiger.ll:158: "\"" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:158\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 158 "src/parse/scantiger.ll"
{start(SC_STRING);}
            YY_BREAK
          case 51: // rule src/parse/scantiger.ll:159: "//" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:159\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 159 "src/parse/scantiger.ll"
{start(SC_SINGLE_COMMENT);}

            YY_BREAK
          case 52: // rule src/parse/scantiger.ll:211: "/*" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:211\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 211 "src/parse/scantiger.ll"
{ nb_comment += 1; start(SC_COMMENT);}

            YY_BREAK
          case 53: // rule src/parse/scantiger.ll:238: [ \t] :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:238\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 238 "src/parse/scantiger.ll"
{}
            YY_BREAK
          case 54: // rule src/parse/scantiger.ll:239: \n|\r|\n\r|\r\n :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:239\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 239 "src/parse/scantiger.ll"
{td.location_.lines(yyleng);}
            YY_BREAK
          case 55: // rule src/parse/scantiger.ll:240: "_exp" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:240\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 240 "src/parse/scantiger.ll"
{return TOKEN(EXP);}
            YY_BREAK
          case 56: // rule src/parse/scantiger.ll:241: "_lvalue" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:241\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 241 "src/parse/scantiger.ll"
{return TOKEN(LVALUE);}
            YY_BREAK
          case 57: // rule src/parse/scantiger.ll:242: "_chunks" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:242\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 242 "src/parse/scantiger.ll"
{return TOKEN(CHUNKS);}
            YY_BREAK
          case 58: // rule src/parse/scantiger.ll:243: . :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:243\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 243 "src/parse/scantiger.ll"
{  td.error_ << td.location_ << ": "  << misc::error::error_type::scan << "Unexpected " << text() << " found\n" ; start(INITIAL); }

            YY_BREAK
        }
        break;
      case SC_COMMENT:
        matcher().pattern(PATTERN_SC_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule src/parse/scantiger.ll:225\033[0m start(" << start() << ")\n";
#line 225 "src/parse/scantiger.ll"
{  td.error_ << td.location_ << ": "  << misc::error::error_type::scan << "Unexpected EOF found\n" ; start(INITIAL); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:214: "/*" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:214\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 214 "src/parse/scantiger.ll"
{ nb_comment += 1 ;}
            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:215: "*/" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:215\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 215 "src/parse/scantiger.ll"
{ if (nb_comment == 1)
 {
  nb_comment -=1;
  start(INITIAL);
 }
 else
 {
  nb_comment -=1;
  } ;}
            YY_BREAK
          case 3: // rule src/parse/scantiger.ll:224: . :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:224\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 224 "src/parse/scantiger.ll"
{}
            YY_BREAK
        }
        break;
      case SC_STRING:
        matcher().pattern(PATTERN_SC_STRING);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule src/parse/scantiger.ll:206\033[0m start(" << start() << ")\n";
#line 206 "src/parse/scantiger.ll"
{ td.error_ << td.location_ << ": " << misc::error::error_type::scan << "Unexpected EOF found\n"  ; start(INITIAL); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:165: \\a :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:165\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 165 "src/parse/scantiger.ll"
{actu = actu.append(text());}
            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:166: \\b :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:166\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 166 "src/parse/scantiger.ll"
{actu = actu.append(text());}
            YY_BREAK
          case 3: // rule src/parse/scantiger.ll:167: \\f :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:167\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 167 "src/parse/scantiger.ll"
{actu = actu.append(text());}
            YY_BREAK
          case 4: // rule src/parse/scantiger.ll:168: \\n :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:168\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 168 "src/parse/scantiger.ll"
{actu = actu.append(text());}
            YY_BREAK
          case 5: // rule src/parse/scantiger.ll:169: \\r :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:169\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 169 "src/parse/scantiger.ll"
{actu = actu.append(text());}
            YY_BREAK
          case 6: // rule src/parse/scantiger.ll:170: \\t :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:170\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 170 "src/parse/scantiger.ll"
{actu = actu.append(text());}
            YY_BREAK
          case 7: // rule src/parse/scantiger.ll:171: \\v :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:171\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 171 "src/parse/scantiger.ll"
{actu = actu.append(text());}
            YY_BREAK
          case 8: // rule src/parse/scantiger.ll:172: [\a\b\f\n\r\t\v] :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:172\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 172 "src/parse/scantiger.ll"
{actu = actu.append((text()));}

            YY_BREAK
          case 9: // rule src/parse/scantiger.ll:174: \\[0-7]{3} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:174\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 174 "src/parse/scantiger.ll"
{ std::string res = text(); res.erase(0,1); int num = stoi(res,0,8);
if (num >  255)
{
  td.error_ << td.location_ << ": " << misc::error::error_type::scan << "Wrong number in octal\n"  ;
}
else {
  char asc = num;
  std::string res(1,asc);
  actu = actu.append((res));
};
}

            YY_BREAK
          case 10: // rule src/parse/scantiger.ll:186: \\x[0-9A-Fa-f]{2} :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:186\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 186 "src/parse/scantiger.ll"
{std::string res = text(); res.erase(0,2); int num = stoi(res,0,16);
if (num >  255)
{
  td.error_ << td.location_ << ": " << misc::error::error_type::scan << "Wrong number in hexa\n"  ;
}
else {
  char asc = num;
  std::string res(1,asc);
  actu = actu.append((res));
};
}
            YY_BREAK
          case 11: // rule src/parse/scantiger.ll:197: ['"'] :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:197\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 197 "src/parse/scantiger.ll"
{ std::string res ; res = actu ; actu = ""; start(INITIAL);return TOKEN_VAL(STRING,res);}

            YY_BREAK
          case 12: // rule src/parse/scantiger.ll:199: \\\" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:199\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 199 "src/parse/scantiger.ll"
{actu = actu.append("\\");actu = actu.append("\""); }

            YY_BREAK
          case 13: // rule src/parse/scantiger.ll:201: \\\\ :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:201\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 201 "src/parse/scantiger.ll"
{ actu = actu.append(text());}


            YY_BREAK
          case 14: // rule src/parse/scantiger.ll:204: . :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:204\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 204 "src/parse/scantiger.ll"
{ actu = actu.append(text());}
            YY_BREAK
          case 15: // rule src/parse/scantiger.ll:205: \\. :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:205\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 205 "src/parse/scantiger.ll"
{td.error_ << td.location_ << ": " << misc::error::error_type::scan << "Unexpected backslash found\n"  ; }
            YY_BREAK
        }
        break;
      case SC_SINGLE_COMMENT:
        matcher().pattern(PATTERN_SC_SINGLE_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              if (debug()) std::cerr << "--\033[1;35mEOF rule src/parse/scantiger.ll:234\033[0m start(" << start() << ")\n";
#line 234 "src/parse/scantiger.ll"
{  td.error_ << td.location_ << ": "  << misc::error::error_type::scan << "Unexpected EOF found\n" ; start(INITIAL); }
            }
            else
            {
              if (debug()) std::cerr << "--\033[1;31mdefault rule\033[0m\n";
              output(matcher().input());
            }
            YY_BREAK
          case 1: // rule src/parse/scantiger.ll:231: "//" :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:231\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 231 "src/parse/scantiger.ll"
{ start(INITIAL);}
            YY_BREAK
          case 2: // rule src/parse/scantiger.ll:232: . :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:232\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 232 "src/parse/scantiger.ll"
{}
            YY_BREAK
          case 3: // rule src/parse/scantiger.ll:233: \n|\r|\n\r|\r\n :
            if (debug()) std::cerr << "--\033[1;35mrule src/parse/scantiger.ll:233\033[0m start(" << start() << ") " << matcher().lineno() << "," << matcher().columno() << ":\"\033[1m" << matcher().text() << "\033[0m\"\n";
            YY_USER_ACTION
#line 233 "src/parse/scantiger.ll"
{td.error_ << td.location_ << ": "  << misc::error::error_type::scan << "Unexpected newline found\n" ; start(INITIAL);}
            YY_BREAK
        }
        break;
      default:
        start(0);
    }
  }
}
