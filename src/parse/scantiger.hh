// src/parse/scantiger.hh generated by reflex 6.0.0 from src/parse/scantiger.ll

#ifndef REFLEX_SRC_PARSE_SCANTIGER_HH
#define REFLEX_SRC_PARSE_SCANTIGER_HH
#define yyIN_HEADER 1
#define REFLEX_VERSION "6.0.0"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#undef REFLEX_OPTION_YYLTYPE
#undef REFLEX_OPTION_YYSTYPE
#undef REFLEX_OPTION_bison_cc
#undef REFLEX_OPTION_bison_cc_namespace
#undef REFLEX_OPTION_bison_cc_parser
#undef REFLEX_OPTION_bison_complete
#undef REFLEX_OPTION_bison_locations
#undef REFLEX_OPTION_debug
#undef REFLEX_OPTION_flex
#undef REFLEX_OPTION_header_file
#undef REFLEX_OPTION_lex
#undef REFLEX_OPTION_lexer
#undef REFLEX_OPTION_namespace
#undef REFLEX_OPTION_noyywrap
#undef REFLEX_OPTION_outfile
#undef REFLEX_OPTION_params
#undef REFLEX_OPTION_prefix
#undef REFLEX_OPTION_token_eof
#undef REFLEX_OPTION_token_type

#define REFLEX_OPTION_YYLTYPE             parse::location
#define REFLEX_OPTION_YYSTYPE             parse::parser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  parse
#define REFLEX_OPTION_bison_cc_parser     parser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_debug               true
#define REFLEX_OPTION_flex                true
#define REFLEX_OPTION_header_file         "src/parse/scantiger.hh"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           parse
#define REFLEX_OPTION_noyywrap            true
#define REFLEX_OPTION_outfile             "src/parse/scantiger.cc"
#define REFLEX_OPTION_params              ::parse::TigerDriver& td
#define REFLEX_OPTION_prefix              yy
#define REFLEX_OPTION_token_eof           parse::parser::symbol_type(0, location())
#define REFLEX_OPTION_token_type          parse::parser::symbol_type

// --debug option enables ASSERT:
#define ASSERT(c) assert(c)

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top user code                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 17 "src/parse/scantiger.ll"


#define YY_EXTERN_C extern "C" // For linkage rule

#include <cerrno>
#include <climits>
#include <regex>
#include <string>

#include <boost/lexical_cast.hpp>

#include <misc/contract.hh>
  // Using misc::escape is very useful to quote non printable characters.
  // For instance
  //
  //    std::cerr << misc::escape('\n') << '\n';
  //
  // reports about `\n' instead of an actual new-line character.
#include <misc/escape.hh>
#include <misc/symbol.hh>
#include <parse/parsetiger.hh>
#include <parse/tiger-driver.hh>

  // FIXED: Some code was deleted here (Define YY_USER_ACTION to update locations)
#define YY_USER_ACTION td.location_.columns(yyleng);


#define TOKEN(Type)                             \
  parser::make_ ## Type(td.location_)

#define TOKEN_VAL(Type, Value)                  \
  parser::make_ ## Type(Value, td.location_)

# define CHECK_EXTENSION()                              \
  do {                                                  \
    if (!td.enable_extensions_p_)                       \
      td.error_ << misc::error::error_type::scan        \
                << td.location_                         \
                << ": invalid identifier: `"            \
                << misc::escape(text()) << "'\n";       \
  } while (false)




////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  FLEX-COMPATIBLE ABSTRACT LEXER CLASS                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/flexlexer.h>

namespace parse {

typedef reflex::FlexLexer<reflex::Matcher> FlexLexer;

} // namespace parse

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace parse {

class Lexer : public FlexLexer {
#line 73 "src/parse/scantiger.ll"

  // FIXED: Some code was deleted here (Local variables).
  int nb_comment = 0;
  int string_len = 0;
  std::string actu = "";


 public:
  Lexer(
      // a persistent source of input, empty by default
      const reflex::Input& input = reflex::Input(),
      // optional output stream, NULL means std::cout by default
      std::ostream *os = NULL)
    :
      FlexLexer(input, os)
  {
    set_debug(true);
  }
  std::string filename;
  // bison-complete bison-locations: location() returns lexeme location
  virtual parse::location location(void)
  {
    parse::location yylloc;
    yylloc.begin.filename = &filename;
    yylloc.begin.line = static_cast<unsigned int>(matcher().lineno());
    yylloc.begin.column = static_cast<unsigned int>(matcher().columno());
    yylloc.end.filename = &filename;
    yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.end.column = static_cast<unsigned int>(matcher().columno_end());
    return yylloc;
  }
  virtual parse::parser::symbol_type yylex(void)
  {
    LexerError("Lexer::yylex invoked but %option lex=lex is used");
    yyterminate();
  }
  // the flex bison-complete lexer function defined by SECTION 2
  virtual parse::parser::symbol_type lex(::parse::TigerDriver& td);
};

} // namespace parse

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


#endif
